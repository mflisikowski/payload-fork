---
title: Rich Text Editor (Lexical)
label: Rich Text (Extended)
order: 05
desc: The officially supported Lexical rich text adapter for Payload - comprehensive technical documentation
keywords: lexical, rich text, editor, headless cms, typescript, features, plugins, react, server, client
---

<Banner type="warning">
**Original Documentation**: The content below comes from [official PayloadCMS documentation](/docs/rich-text/overview).
Further in the document, you'll find an extended, more detailed version of this documentation.
</Banner>

<Banner type="success">

This documentation is about our new editor, based on Lexical (Meta's rich text editor). The previous default
editor was based on Slate and is still supported. You can read [its documentation](/docs/rich-text/slate),
or the optional [migration guide](/docs/rich-text/migration) to migrate from Slate to Lexical (recommended).

</Banner>

The editor is the most important property of the [rich text field](/docs/fields/rich-text).

As a key part of Payload, we are proud to offer you the best editing experience you can imagine. With healthy
defaults out of the box, but also with the flexibility to customize every detail: from the "/" menu
and toolbars (whether inline or fixed) to inserting any component or subfield you can imagine.

To use the rich text editor, first you need to install it:

```bash
pnpm install @payloadcms/richtext-lexical
```

Once you have it installed, you can pass it to your top-level Payload Config as follows:

```ts
import { buildConfig } from 'payload'
import { lexicalEditor } from '@payloadcms/richtext-lexical'

export default buildConfig({
  collections: [
    // your collections here
  ],
  // Pass the Lexical editor to the root config
  editor: lexicalEditor({}),
})
```

You can also override Lexical settings on a field-by-field basis as follows:

```ts
import type { CollectionConfig } from 'payload'
import { lexicalEditor } from '@payloadcms/richtext-lexical'

export const Pages: CollectionConfig = {
  slug: 'pages',
  fields: [
    {
      name: 'content',
      type: 'richText',
      // Pass the Lexical editor here and override base settings as necessary
      editor: lexicalEditor({}),
    },
  ],
}
```

## Extending the lexical editor with Features

Lexical has been designed with extensibility in mind. Whether you're aiming to introduce new functionalities or tweak the existing ones, Lexical makes it seamless for you to bring those changes to life.

### Features: The Building Blocks

At the heart of Lexical's customization potential are "features". While Lexical ships with a set of default features we believe are essential for most use cases, the true power lies in your ability to redefine, expand, or prune these as needed.

If you remove all the default features, you're left with a blank editor. You can then add in only the features you need, or you can build your own custom features from scratch.

### Integrating New Features

To weave in your custom features, utilize the `features` prop when initializing the Lexical Editor. Here's a basic example of how this is done:

```ts
import {
  BlocksFeature,
  LinkFeature,
  UploadFeature,
  lexicalEditor,
} from '@payloadcms/richtext-lexical'
import { Banner } from '../blocks/Banner'
import { CallToAction } from '../blocks/CallToAction'

{
  editor: lexicalEditor({
    features: ({ defaultFeatures, rootFeatures }) => [
      ...defaultFeatures,
      LinkFeature({
        // Example showing how to customize the built-in fields
        // of the Link feature
        fields: ({ defaultFields }) => [
          ...defaultFields,
          {
            name: 'rel',
            label: 'Rel Attribute',
            type: 'select',
            hasMany: true,
            options: ['noopener', 'noreferrer', 'nofollow'],
            admin: {
              description:
                'The rel attribute defines the relationship between a linked resource and the current document. This is a custom link field.',
            },
          },
        ],
      }),
      UploadFeature({
        collections: {
          uploads: {
            // Example showing how to customize the built-in fields
            // of the Upload feature
            fields: [
              {
                name: 'caption',
                type: 'richText',
                editor: lexicalEditor(),
              },
            ],
          },
        },
      }),
      // This is incredibly powerful. You can re-use your Payload blocks
      // directly in the Lexical editor as follows:
      BlocksFeature({
        blocks: [Banner, CallToAction],
      }),
    ],
  })
}
```

`features` can be both an array of features, or a function returning an array of features. The function provides the following props:

| Prop                  | Description                                                                                                                                                                                                                                            |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`defaultFeatures`** | This opinionated array contains all "recommended" default features. You can see which features are included in the default features in the table below.                                                                                                |
| **`rootFeatures`**    | This array contains all features that are enabled in the root richText editor (the one defined in the payload.config.ts). If this field is the root richText editor, or if the root richText editor is not a lexical editor, this array will be empty. |

## Official Features

You can find more information about the official features in our [official features docs](../rich-text/official-features).

## Creating your own, custom Feature

You can find more information about creating your own feature in our [building custom feature docs](../rich-text/custom-features).

## TypeScript

Every single piece of saved data is 100% fully typed within lexical. It provides a type for every single node, which can be imported from `@payloadcms/richtext-lexical` - each type is prefixed with `Serialized`, e.g., `SerializedUploadNode`.

To fully type the entire editor JSON, you can use our `TypedEditorState` helper type, which accepts a union of all possible node types as a generic. We don't provide a type that already contains all possible node types because they depend on which features you have enabled in your editor. Here is an example:

```ts
import type {
  SerializedAutoLinkNode,
  SerializedBlockNode,
  SerializedHorizontalRuleNode,
  SerializedLinkNode,
  SerializedListItemNode,
  SerializedListNode,
  SerializedParagraphNode,
  SerializedQuoteNode,
  SerializedRelationshipNode,
  SerializedTextNode,
  SerializedUploadNode,
  TypedEditorState,
  SerializedHeadingNode,
} from '@payloadcms/richtext-lexical'

const editorState: TypedEditorState<
  | SerializedAutoLinkNode
  | SerializedBlockNode
  | SerializedHorizontalRuleNode
  | SerializedLinkNode
  | SerializedListItemNode
  | SerializedListNode
  | SerializedParagraphNode
  | SerializedQuoteNode
  | SerializedRelationshipNode
  | SerializedTextNode
  | SerializedUploadNode
  | SerializedHeadingNode
> = {
  root: {
    type: 'root',
    direction: 'ltr',
    format: '',
    indent: 0,
    version: 1,
    children: [
      {
        children: [
          {
            detail: 0,
            format: 0,
            mode: 'normal',
            style: '',
            text: 'Some text. Every property here is fully-typed',
            type: 'text',
            version: 1,
          },
        ],
        direction: 'ltr',
        format: '',
        indent: 0,
        type: 'paragraph',
        textFormat: 0,
        version: 1,
      },
    ],
  },
}
```

Alternatively, you can use the `DefaultTypedEditorState` type, which includes all types for all nodes included in the `defaultFeatures`:

```ts
import type { DefaultTypedEditorState } from '@payloadcms/richtext-lexical'

const editorState: DefaultTypedEditorState = {
  root: {
    type: 'root',
    direction: 'ltr',
    format: '',
    indent: 0,
    version: 1,
    children: [
      {
        children: [
          {
            detail: 0,
            format: 0,
            mode: 'normal',
            style: '',
            text: 'Some text. Every property here is fully-typed',
            type: 'text',
            version: 1,
          },
        ],
        direction: 'ltr',
        format: '',
        indent: 0,
        type: 'paragraph',
        textFormat: 0,
        version: 1,
      },
    ],
  },
}
```

Just like `TypedEditorState`, the `DefaultTypedEditorState` also accepts an optional node type union as a generic. Here, this would **add** the specified node types to the default ones. Example:

```ts
DefaultTypedEditorState<SerializedBlockNode | YourCustomSerializedNode>
```

This is a type-safe representation of the editor state. If you look at the auto suggestions of a node's `type` property, you will see all the possible node types you can use.

Make sure to only use types exported from `@payloadcms/richtext-lexical`, not from the lexical core packages. We only have control over the types we export and can make sure they're correct, even though the lexical core may export types with identical names.

### Automatic type generation

Lexical does not generate accurate type definitions for your richText fields for you yet - this will be improved in the future. Currently, it only outputs the rough shape of the editor JSON, which you can enhance using type assertions.

## Admin customization

The Rich Text Field editor configuration has an `admin` property with the following options:

| Property                        | Description                                                                                                 |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **`placeholder`**               | Set this property to define a placeholder string for the field.                                             |
| **`hideGutter`**                | Set this property to `true` to hide this field's gutter within the Admin Panel.                             |
| **`hideInsertParagraphAtEnd`**  | Set this property to `true` to hide the "+" button that appears at the end of the editor.                   |
| **`hideDraggableBlockElement`** | Set this property to `true` to hide the draggable element that appears when you hover a node in the editor. |
| **`hideAddBlockButton`**        | Set this property to `true` to hide the "+" button that appears when you hover a node in the editor.        |

### Disable the gutter

You can disable the gutter (the vertical line padding between the editor and the left edge of the screen) by setting the `hideGutter` prop to `true`:

```ts
{
  name: 'richText',
  type: 'richText',
  editor: lexicalEditor({
    admin: {
      hideGutter: true
    },
  }),
}
```

### Customize the placeholder

You can customize the placeholder (the text that appears in the editor when it's empty) by setting the `placeholder` prop:

```ts
{
  name: 'richText',
  type: 'richText',
  editor: lexicalEditor({
    admin: {
      placeholder: 'Type your content here...'
    },
  }),
}
```

## Detecting empty editor state

When you first type into a rich text field and subsequently delete everything through the admin panel, its value changes from `null` to a JSON object containing an empty paragraph.

If needed, you can reset the field value to `null` programmatically - for example, by using a custom hook to detect when the editor is empty.

This also applies to fields like `text` and `textArea`, which could be stored as either `null` or an empty value in the database. Since the empty value for richText is a JSON object, checking for emptiness is a bit more involved - so Payload provides a utility for it:

```ts
import { hasText } from '@payloadcms/richtext-lexical/shared'

hasText(richtextData)
```

---

## ðŸ“š Extended Documentation

<Banner type="success">
**Note**: The documentation below has been automatically generated based on source code analysis and contains more detailed information than the original documentation above.
</Banner>

![NPM Version](https://img.shields.io/npm/v/@payloadcms/richtext-lexical)
![Bundle Size](https://img.shields.io/bundlephobia/minzip/@payloadcms/richtext-lexical)

## Detailed Overview

The `@payloadcms/richtext-lexical` package is the officially supported rich text editor adapter for PayloadCMS, built on Meta's powerful Lexical editor framework. This package provides a modern, extensible, and feature-rich editing experience that has become the default choice for PayloadCMS applications, replacing the previous Slate-based editor.

This adapter serves as a bridge between Lexical's powerful editing capabilities and PayloadCMS's content management system, offering:
- **Modern Architecture**: Built on Meta's Lexical framework, ensuring long-term support and cutting-edge features
- **Extensible Design**: Modular feature system allowing complete customization and extension
- **TypeScript First**: Full TypeScript support with comprehensive type definitions
- **Server-Side Rendering**: Built-in support for SSR and RSC (React Server Components)
- **Performance Optimized**: Efficient rendering with React 19 support and optimized bundle sizes

The package is designed for developers who need a robust rich text solution that can scale from simple blog posts to complex document editing workflows, with the flexibility to customize every aspect of the editing experience.

<Banner type="info">
The package is open-source. [View source code](https://github.com/payloadcms/payload/tree/main/packages/richtext-lexical). Need help? [Community Help](https://payloadcms.com/community-help).
</Banner>

## System Requirements

- **PayloadCMS**: `workspace:*` (latest version)
- **Node.js**: `^18.20.2 || >=20.9.0`
- **React**: `^19.0.0 || ^19.0.0-rc-65a56d0e-20241020`
- **React DOM**: `^19.0.0 || ^19.0.0-rc-65a56d0e-20241020`
- **TypeScript**: 4.5 or higher (recommended)

### Additional Requirements

- **Lexical Framework**: `0.28.0` (automatically managed)
- **Modern JavaScript Environment**: ES2020+ support
- **Browser Support**: Modern browsers with ES6+ support

## Installation

```bash
# npm
npm install @payloadcms/richtext-lexical

# yarn
yarn add @payloadcms/richtext-lexical

# pnpm
pnpm add @payloadcms/richtext-lexical
```

### Peer Dependencies
This package requires the following peer dependencies:
```bash
# Core dependencies
npm install payload react react-dom

# Optional UI dependencies (for advanced features)
npm install @faceless-ui/modal @faceless-ui/scroll-info @payloadcms/next
```

## Quick Start

Basic configuration for immediate use:

```typescript
// payload.config.ts
import { buildConfig } from 'payload'
import { lexicalEditor } from '@payloadcms/richtext-lexical'

export default buildConfig({
  // Global editor configuration
  editor: lexicalEditor({
    // Use default features - includes all essential functionality
    features: ({ defaultFeatures }) => defaultFeatures,
  }),
  
  collections: [
    {
      slug: 'posts',
      fields: [
        {
          name: 'content',
          type: 'richText',
          // Editor inherits global configuration
          required: true,
        },
        {
          name: 'excerpt',
          type: 'richText',
          // Override with custom configuration
          editor: lexicalEditor({
            features: ({ defaultFeatures }) => 
              // Remove features not needed for excerpts
              defaultFeatures.filter(feature => 
                !['UploadFeature', 'BlocksFeature'].includes(feature.key)
              ),
          }),
        },
      ],
    },
  ],
})
```

## Detailed Configuration

### Main Options

#### `features`

- **Type**: `FeaturesInput`
- **Default value**: `defaultFeatures`
- **Required**: `false`

The features array or function that defines which editing capabilities are available in the editor. This is the primary customization point for the Lexical editor.

```typescript
// Array format
editor: lexicalEditor({
  features: [
    BoldFeature(),
    ItalicFeature(),
    LinkFeature({
      fields: ({ defaultFields }) => [
        ...defaultFields,
        {
          name: 'openInNewTab',
          type: 'checkbox',
          label: 'Open in new tab',
        },
      ],
    }),
  ],
})

// Function format (recommended)
editor: lexicalEditor({
  features: ({ defaultFeatures, rootFeatures }) => [
    ...defaultFeatures,
    // Add custom features
    BlocksFeature({
      blocks: [CallToActionBlock, TestimonialBlock],
    }),
    // Override existing features
    UploadFeature({
      collections: {
        media: {
          fields: [
            {
              name: 'alt',
              type: 'text',
              required: true,
            },
          ],
        },
      },
    }),
  ],
})
```

##### Function Parameters:
- **`defaultFeatures`**: Array of recommended features for most use cases
- **`rootFeatures`**: Features from the global editor configuration (useful for inheritance)

#### `admin`

- **Type**: `LexicalFieldAdminProps`
- **Default value**: `{}`
- **Required**: `false`

Configuration options for the admin UI appearance and behavior.

```typescript
editor: lexicalEditor({
  admin: {
    // Customize placeholder text
    placeholder: 'Start writing your content...',
    
    // Hide UI elements for a cleaner interface
    hideGutter: false,
    hideAddBlockButton: false,
    hideDraggableBlockElement: false,
    hideInsertParagraphAtEnd: false,
  },
})
```

##### Sub-options:
| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `placeholder` | `string \| LabelFunction` | `undefined` | Placeholder text shown when editor is empty |
| `hideGutter` | `boolean` | `false` | Hide the left gutter and vertical guide line |
| `hideAddBlockButton` | `boolean` | `false` | Hide the "+" button for adding blocks |
| `hideDraggableBlockElement` | `boolean` | `false` | Hide drag handles for blocks |
| `hideInsertParagraphAtEnd` | `boolean` | `false` | Hide the paragraph insertion button at the end |

#### `lexical`

- **Type**: `LexicalEditorConfig`
- **Default value**: Default Lexical configuration with PayloadCMS theme
- **Required**: `false`

Low-level Lexical editor configuration for advanced customization.

```typescript
import { LexicalEditorTheme } from '@payloadcms/richtext-lexical'

editor: lexicalEditor({
  lexical: {
    namespace: 'my-custom-editor',
    theme: {
      ...LexicalEditorTheme,
      // Override theme properties
      paragraph: 'custom-paragraph-class',
      heading: {
        h1: 'custom-h1-class',
        h2: 'custom-h2-class',
      },
    },
    // Add custom nodes (advanced)
    nodes: [],
  },
})
```

### Configuration Schema

```typescript
interface LexicalEditorProps {
  // Feature configuration
  features?: FeaturesInput
  
  // Admin UI configuration
  admin?: LexicalFieldAdminProps
  
  // Low-level Lexical configuration
  lexical?: LexicalEditorConfig
}

interface LexicalFieldAdminProps {
  placeholder?: string | LabelFunction
  hideGutter?: boolean
  hideAddBlockButton?: boolean
  hideDraggableBlockElement?: boolean
  hideInsertParagraphAtEnd?: boolean
}

// Features can be an array or function
type FeaturesInput = 
  | FeatureProviderServer[]
  | (({ defaultFeatures, rootFeatures }) => FeatureProviderServer[])

interface LexicalEditorConfig {
  namespace?: string
  theme?: EditorThemeClasses
  nodes?: Klass<LexicalNode>[]
  onError?: (error: Error, editor: LexicalEditor) => void
  // ... other Lexical configuration options
}
```

## Usage Guides

### Creating a Blog Editor

Complete setup for a blog content management system:

```typescript
// payload.config.ts
import { buildConfig } from 'payload'
import { 
  lexicalEditor, 
  HeadingFeature, 
  BoldFeature, 
  ItalicFeature,
  LinkFeature,
  UploadFeature,
  BlockquoteFeature,
  UnorderedListFeature,
  OrderedListFeature,
} from '@payloadcms/richtext-lexical'

export default buildConfig({
  collections: [
    {
      slug: 'posts',
      fields: [
        {
          name: 'title',
          type: 'text',
          required: true,
        },
        {
          name: 'content',
          type: 'richText',
          editor: lexicalEditor({
            features: ({ defaultFeatures }) => [
              // Basic formatting
              BoldFeature(),
              ItalicFeature(),
              
              // Structure
              HeadingFeature({ enabledHeadingSizes: ['h2', 'h3', 'h4'] }),
              UnorderedListFeature(),
              OrderedListFeature(),
              BlockquoteFeature(),
              
              // Media and links
              LinkFeature({
                fields: ({ defaultFields }) => [
                  ...defaultFields,
                  {
                    name: 'nofollow',
                    type: 'checkbox',
                    label: 'Add nofollow attribute',
                    admin: {
                      description: 'Prevent search engines from following this link',
                    },
                  },
                ],
              }),
              UploadFeature({
                collections: {
                  media: {
                    fields: [
                      {
                        name: 'alt',
                        type: 'text',
                        label: 'Alt Text',
                        required: true,
                      },
                      {
                        name: 'caption',
                        type: 'richText',
                        label: 'Caption',
                        editor: lexicalEditor({
                          features: [BoldFeature(), ItalicFeature()],
                        }),
                      },
                    ],
                  },
                },
              }),
            ],
          }),
        },
      ],
    },
  ],
})
```

### Building Custom Block Components

Create reusable content blocks for complex layouts:

```typescript
// blocks/CallToAction.ts
import type { Block } from 'payload'

export const CallToActionBlock: Block = {
  slug: 'callToAction',
  labels: {
    singular: 'Call to Action',
    plural: 'Calls to Action',
  },
  fields: [
    {
      name: 'heading',
      type: 'text',
      required: true,
    },
    {
      name: 'description',
      type: 'textarea',
    },
    {
      name: 'button',
      type: 'group',
      fields: [
        {
          name: 'text',
          type: 'text',
          required: true,
        },
        {
          name: 'url',
          type: 'text',
          required: true,
        },
        {
          name: 'style',
          type: 'select',
          options: ['primary', 'secondary', 'outline'],
          defaultValue: 'primary',
        },
      ],
    },
  ],
}

// Using in editor configuration
import { BlocksFeature } from '@payloadcms/richtext-lexical'
import { CallToActionBlock } from './blocks/CallToAction'

editor: lexicalEditor({
  features: ({ defaultFeatures }) => [
    ...defaultFeatures,
    BlocksFeature({
      blocks: [CallToActionBlock],
    }),
  ],
})
```

### Advanced Patterns

#### Custom Feature Development

Create your own feature for specialized content types:

```typescript
// features/customEmbed/server/index.ts
import { createServerFeature } from '@payloadcms/richtext-lexical'

export const CustomEmbedFeature = createServerFeature({
  key: 'customEmbed',
  nodes: [
    {
      node: import('./nodes/CustomEmbedNode'),
      type: 'customEmbed',
    },
  ],
  plugins: [
    {
      Component: () => import('./plugins/CustomEmbedPlugin'),
      position: 'normal',
    },
  ],
})

// features/customEmbed/server/nodes/CustomEmbedNode.ts
import { $createServerBlockNode, ServerBlockNode } from '@payloadcms/richtext-lexical'

export class CustomEmbedNode extends ServerBlockNode {
  static getType(): string {
    return 'customEmbed'
  }

  static clone(node: CustomEmbedNode): CustomEmbedNode {
    return new CustomEmbedNode(node.__fields, node.__key)
  }

  getFields() {
    return [
      {
        name: 'url',
        type: 'text',
        required: true,
      },
      {
        name: 'provider',
        type: 'select',
        options: ['youtube', 'vimeo', 'codepen'],
        required: true,
      },
    ]
  }
}
```

#### Multi-Editor Configuration

Different editors for different content types:

```typescript
// Create specialized editor configurations
const blogEditorConfig = {
  features: ({ defaultFeatures }) => [
    ...defaultFeatures.filter(f => f.key !== 'upload'), // Remove uploads for blog
    HeadingFeature({ enabledHeadingSizes: ['h2', 'h3'] }),
  ],
}

const pageEditorConfig = {
  features: ({ defaultFeatures }) => [
    ...defaultFeatures,
    BlocksFeature({
      blocks: [HeroBlock, FeatureGrid, TestimonialCarousel],
    }),
    UploadFeature({
      collections: {
        media: {
          fields: [/* custom media fields */],
        },
      },
    }),
  ],
}

// Apply to different collections
export default buildConfig({
  collections: [
    {
      slug: 'blog-posts',
      fields: [
        {
          name: 'content',
          type: 'richText',
          editor: lexicalEditor(blogEditorConfig),
        },
      ],
    },
    {
      slug: 'pages',
      fields: [
        {
          name: 'content',
          type: 'richText',
          editor: lexicalEditor(pageEditorConfig),
        },
      ],
    },
  ],
})
```

## API Reference

### Functions

#### `lexicalEditor(props?: LexicalEditorProps)`

Main factory function that creates a Lexical rich text adapter for PayloadCMS.

**Parameters:**
- `props`: `LexicalEditorProps` - Configuration object for the editor

**Returns:** `LexicalRichTextAdapterProvider` - A function that creates the adapter during Payload's initialization

**Example:**
```typescript
import { lexicalEditor } from '@payloadcms/richtext-lexical'

const adapter = lexicalEditor({
  features: ({ defaultFeatures }) => defaultFeatures,
  admin: {
    placeholder: 'Start writing...',
  },
})
```

#### `hasText(editorState: SerializedEditorState | null)`

Utility function to check if a rich text field contains actual content.

**Parameters:**
- `editorState`: `SerializedEditorState | null` - The editor state to check

**Returns:** `boolean` - True if the editor contains meaningful text content

**Example:**
```typescript
import { hasText } from '@payloadcms/richtext-lexical/shared'

const isEmpty = !hasText(document.content)
if (isEmpty) {
  console.log('Content field is empty')
}
```

### Core Features

#### `BoldFeature()`
Enables bold text formatting with Ctrl/Cmd+B shortcut.

**Example:**
```typescript
import { BoldFeature } from '@payloadcms/richtext-lexical'

BoldFeature() // No configuration needed
```

#### `ItalicFeature()`
Enables italic text formatting with Ctrl/Cmd+I shortcut.

#### `UnderlineFeature()`
Enables underlined text formatting with Ctrl/Cmd+U shortcut.

#### `HeadingFeature(props?: HeadingFeatureProps)`
Enables heading elements (h1-h6) with customizable levels.

**Parameters:**
- `enabledHeadingSizes`: `Array<'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'>` - Which heading levels to enable

**Example:**
```typescript
import { HeadingFeature } from '@payloadcms/richtext-lexical'

HeadingFeature({
  enabledHeadingSizes: ['h2', 'h3', 'h4'], // Only allow h2-h4
})
```

#### `LinkFeature(props?: LinkFeatureServerProps)`
Enables link creation and editing with customizable fields.

**Parameters:**
- `fields`: Function to customize link fields
- `validate`: Custom validation function for links

**Example:**
```typescript
import { LinkFeature } from '@payloadcms/richtext-lexical'

LinkFeature({
  fields: ({ defaultFields }) => [
    ...defaultFields,
    {
      name: 'openInNewTab',
      type: 'checkbox',
      label: 'Open in new tab',
    },
    {
      name: 'rel',
      type: 'text',
      label: 'Rel attribute',
    },
  ],
})
```

#### `UploadFeature(props?: UploadFeatureProps)`
Enables media uploads and inline images/files.

**Parameters:**
- `collections`: Configuration for upload collections

**Example:**
```typescript
import { UploadFeature } from '@payloadcms/richtext-lexical'

UploadFeature({
  collections: {
    media: {
      fields: [
        {
          name: 'alt',
          type: 'text',
          required: true,
        },
        {
          name: 'caption',
          type: 'richText',
          editor: lexicalEditor({
            features: [BoldFeature(), ItalicFeature()],
          }),
        },
      ],
    },
  },
})
```

#### `BlocksFeature(props: BlocksFeatureProps)`
Enables Payload blocks as inline rich text components.

**Parameters:**
- `blocks`: Array of Payload block configurations

**Example:**
```typescript
import { BlocksFeature } from '@payloadcms/richtext-lexical'
import { CallToActionBlock, TestimonialBlock } from '../blocks'

BlocksFeature({
  blocks: [CallToActionBlock, TestimonialBlock],
})
```

### React Components

#### `RichTextEditor`

The main editor component that renders the Lexical editor interface.

**Props:**
- Inherits from `RichTextFieldClientProps`
- `initialLexicalFormState`: Initial editor state
- `clientFeatures`: Client-side feature configuration
- `admin`: Admin UI configuration

**Example:**
```tsx
// This component is automatically rendered by PayloadCMS
// You typically don't need to use it directly
```

### Hooks

#### `useEditorConfigContext()`

React hook for accessing the editor configuration context.

**Returns:**
- `editorConfig`: Current editor configuration
- `clientFeatures`: Available client features

**Example:**
```tsx
import { useEditorConfigContext } from '@payloadcms/richtext-lexical/client'

function CustomPlugin() {
  const { editorConfig, clientFeatures } = useEditorConfigContext()
  
  return (
    <div>
      {/* Custom plugin UI */}
    </div>
  )
}
```

### TypeScript Types

```typescript
// Core editor types
export interface LexicalEditorProps {
  features?: FeaturesInput
  admin?: LexicalFieldAdminProps
  lexical?: LexicalEditorConfig
}

export interface LexicalFieldAdminProps {
  placeholder?: string | LabelFunction
  hideGutter?: boolean
  hideAddBlockButton?: boolean
  hideDraggableBlockElement?: boolean
  hideInsertParagraphAtEnd?: boolean
}

// Feature types
export interface FeatureProviderServer<
  TServerFeatureProps,
  TClientFeatureProps, 
  TServerNodes
> {
  key: string
  clientFeatureProps?: TClientFeatureProps
  dependencies?: string[]
  dependenciesPriority?: number
  dependenciesSoft?: string[]
  // ... additional feature properties
}

// Editor state types
export interface TypedEditorState<TNodes = any> {
  root: {
    type: 'root'
    children: TNodes[]
    direction: 'ltr' | 'rtl' | null
    format: ElementFormatType
    indent: number
    version: number
  }
}

// Node types (examples)
export interface SerializedTextNode extends SerializedLexicalNode {
  type: 'text'
  text: string
  format: number
  mode: 'normal' | 'token' | 'segmented'
  style: string
  detail: number
}

export interface SerializedParagraphNode extends SerializedElementNode {
  type: 'paragraph'
  textFormat: number
}

export interface SerializedHeadingNode extends SerializedElementNode {
  type: 'heading'
  tag: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'
}

// Default typed editor state with all default features
export type DefaultTypedEditorState<TAdditionalNodes = never> = TypedEditorState<
  | SerializedParagraphNode
  | SerializedHeadingNode
  | SerializedTextNode
  | SerializedLinkNode
  | SerializedListNode
  | SerializedListItemNode
  | SerializedQuoteNode
  | SerializedUploadNode
  | SerializedRelationshipNode
  | SerializedHorizontalRuleNode
  | TAdditionalNodes
>
```

## Integrations

### PayloadCMS Field System

The Lexical editor integrates deeply with PayloadCMS's field system, providing:

#### Field Hooks Integration
- **`beforeValidate`**: Node-level validation before field validation
- **`beforeChange`**: Transform nodes before saving to database  
- **`afterChange`**: Process nodes after successful save
- **`afterRead`**: Transform nodes when reading from database

#### Subfield Support
Features like `BlocksFeature` and `UploadFeature` create nested field structures that integrate with Payload's validation, localization, and access control systems.

```typescript
// Example: Custom feature with subfields
export const CustomFeature = createServerFeature({
  key: 'custom',
  nodes: [{
    node: CustomNode,
    getSubFields: ({ node, req }) => [
      {
        name: 'customField',
        type: 'text',
        validate: (value) => {
          // Field-level validation
          return value ? true : 'Custom field is required'
        },
      },
    ],
    hooks: {
      afterChange: async ({ node, req }) => {
        // Process node after changes
        console.log('Custom node changed:', node)
        return node
      },
    },
  }],
})
```

### Database Integration

#### JSON Storage Format
Rich text content is stored as JSON in the database with the following structure:

```json
{
  "root": {
    "type": "root",
    "children": [
      {
        "type": "paragraph",
        "children": [
          {
            "type": "text",
            "text": "Hello world",
            "format": 1
          }
        ]
      }
    ],
    "direction": "ltr",
    "format": "",
    "indent": 0,
    "version": 1
  }
}
```

#### Migration Support
Built-in migration utilities for upgrading content:

```typescript
import { upgradeLexicalData } from '@payloadcms/richtext-lexical'

// Upgrade legacy content
const upgradedContent = upgradeLexicalData(oldContent)
```

### External Services

#### Content Converters
Multiple export formats supported:

```typescript
// HTML conversion
import { convertLexicalToHTML } from '@payloadcms/richtext-lexical/html'
const html = await convertLexicalToHTML({ data: editorState })

// Markdown conversion  
import { convertLexicalToMarkdown } from '@payloadcms/richtext-lexical'
const markdown = convertLexicalToMarkdown(editorState)

// Plain text conversion
import { convertLexicalToPlaintext } from '@payloadcms/richtext-lexical/plaintext'
const text = convertLexicalToPlaintext(editorState)

// React/JSX conversion
import { JSXConverters } from '@payloadcms/richtext-lexical/react'
const jsx = convertLexicalToReact({ data: editorState, converters: JSXConverters })
```

## Troubleshooting

### Common Issues

#### Editor Not Loading

**Problem:** Editor appears blank or doesn't initialize properly

**Solution:**
1. Check that all peer dependencies are installed
2. Verify React version compatibility (19.x required)
3. Ensure proper feature configuration

**Example:**
```typescript
// Debug configuration
editor: lexicalEditor({
  features: ({ defaultFeatures }) => {
    console.log('Available features:', defaultFeatures.map(f => f.key))
    return defaultFeatures
  },
})
```

#### TypeScript Errors with Node Types

**Problem:** TypeScript errors when working with editor state

**Solution:**
1. Import types from `@payloadcms/richtext-lexical` (not from `lexical`)
2. Use proper generic types for `TypedEditorState`

**Example:**
```typescript
import type { 
  SerializedTextNode,
  SerializedParagraphNode,
  TypedEditorState 
} from '@payloadcms/richtext-lexical'

// Correct typing
const state: TypedEditorState<SerializedTextNode | SerializedParagraphNode> = {
  root: {
    type: 'root',
    children: [/* ... */],
    direction: 'ltr',
    format: '',
    indent: 0,
    version: 1,
  },
}
```

#### Features Not Working

**Problem:** Custom features don't appear or function correctly

**Solution:**
1. Verify feature is properly imported and configured
2. Check feature dependencies are met
3. Ensure client and server feature components are properly registered

**Example:**
```typescript
// Verify feature registration
import { CustomFeature } from './features/custom'

editor: lexicalEditor({
  features: ({ defaultFeatures }) => [
    ...defaultFeatures,
    CustomFeature({
      // Ensure all required props are provided
      requiredProp: 'value',
    }),
  ],
})
```

#### Content Not Saving

**Problem:** Rich text content is not being saved to the database

**Solution:**
1. Check field validation rules
2. Verify no beforeChange hooks are preventing saves
3. Ensure proper permissions are set

**Example:**
```typescript
{
  name: 'content',
  type: 'richText',
  editor: lexicalEditor({
    // Add validation to debug
    validate: (value, { req }) => {
      console.log('Validating content:', value)
      return true // Allow all content for debugging
    },
  }),
  // Check field-level permissions
  access: {
    read: () => true,
    update: () => true,
  },
}
```

### Debugging

#### Enable Debug Logging

```typescript
// Add debug features for development
import { 
  TreeViewFeature,
  TestRecorderFeature,
  DebugJsxConverterFeature 
} from '@payloadcms/richtext-lexical'

editor: lexicalEditor({
  features: ({ defaultFeatures }) => [
    ...defaultFeatures,
    // Only in development
    ...(process.env.NODE_ENV === 'development' ? [
      TreeViewFeature(), // Shows editor state tree
      TestRecorderFeature(), // Records interactions for testing
      DebugJsxConverterFeature(), // Debug JSX conversion
    ] : []),
  ],
})
```

#### Content Inspection

```typescript
// Utility to inspect editor content
import { hasText } from '@payloadcms/richtext-lexical/shared'

function debugContent(content) {
  console.log('Has text:', hasText(content))
  console.log('Content structure:', JSON.stringify(content, null, 2))
  
  // Traverse nodes
  function traverseNodes(nodes, depth = 0) {
    nodes?.forEach(node => {
      console.log('  '.repeat(depth), node.type, node)
      if (node.children) {
        traverseNodes(node.children, depth + 1)
      }
    })
  }
  
  if (content?.root?.children) {
    traverseNodes(content.root.children)
  }
}
```

## Performance

### Performance Optimization

#### Bundle Size Optimization

The package uses advanced bundling techniques to minimize size:

```typescript
// Features are loaded dynamically to reduce initial bundle size
const OptimizedEditor = lexicalEditor({
  features: ({ defaultFeatures }) => [
    // Only include features you actually use
    BoldFeature(),
    ItalicFeature(),
    // Avoid including unused features like BlocksFeature if not needed
  ],
})
```

#### Memory Management

```typescript
// Configure editor for better memory usage
editor: lexicalEditor({
  lexical: {
    // Limit undo/redo history for memory efficiency
    historyState: {
      maxHistorySize: 50, // Default is 100
    },
  },
})
```

#### Rendering Performance

- **React Compiler**: Automatically optimized with Babel React Compiler
- **Server-Side Rendering**: Full SSR support with hydration
- **Code Splitting**: Features are lazy-loaded when needed

#### Large Document Handling

```typescript
// For documents with many blocks/nodes
editor: lexicalEditor({
  features: ({ defaultFeatures }) => [
    ...defaultFeatures,
    BlocksFeature({
      blocks: [/* your blocks */],
      // Configure for better performance with many blocks
      inlineBlocksMode: false, // Render blocks separately
    }),
  ],
  admin: {
    // Reduce UI complexity for better performance
    hideDraggableBlockElement: true, // If not needed
  },
})
```

## Security

### Content Sanitization

The Lexical editor includes built-in security measures:

#### XSS Prevention
- All HTML output is sanitized by default
- User input is validated through the node system
- No direct HTML insertion capabilities

#### Link Validation
```typescript
import { validateUrl, sanitizeUrl } from '@payloadcms/richtext-lexical'

// Built-in URL validation
const isValid = validateUrl('https://example.com')
const cleanUrl = sanitizeUrl(userInput)

// Custom link validation
LinkFeature({
  validate: ({ url, text, fields }) => {
    // Custom validation logic
    if (!url.startsWith('https://')) {
      return 'Links must use HTTPS'
    }
    return true
  },
})
```

#### Upload Security
When using `UploadFeature`, ensure proper upload validation:

```typescript
UploadFeature({
  collections: {
    media: {
      fields: [
        {
          name: 'alt',
          type: 'text',
          validate: (value) => {
            // Sanitize alt text
            if (value && value.length > 200) {
              return 'Alt text must be under 200 characters'
            }
            return true
          },
        },
      ],
    },
  },
})
```

### Access Control Integration

Rich text fields respect PayloadCMS access control:

```typescript
{
  name: 'content',
  type: 'richText',
  editor: lexicalEditor({
    // Features can check permissions
    features: ({ defaultFeatures }) => [
      ...defaultFeatures,
      // Only allow uploads if user has media permissions
      ...(req?.user?.permissions?.canUpload ? [UploadFeature()] : []),
    ],
  }),
  access: {
    read: ({ req }) => {
      // Control who can read rich text content
      return req.user?.role === 'admin' || req.user?.role === 'editor'
    },
    update: ({ req }) => {
      // Control who can edit rich text content
      return req.user?.role === 'admin'
    },
  },
}
```

## Migration

### From Slate to Lexical

Comprehensive migration guide and tools:

#### Migration Utility

```typescript
import { SlateToLexicalFeature } from '@payloadcms/richtext-lexical'

// Add to editor configuration during migration
editor: lexicalEditor({
  features: ({ defaultFeatures }) => [
    ...defaultFeatures,
    SlateToLexicalFeature({
      // Configure migration options
      convertOnSave: true,
      backupOriginal: true,
    }),
  ],
})
```

#### Data Migration Script

```typescript
// scripts/migrateToLexical.ts
import { convertSlateToLexical } from '@payloadcms/richtext-lexical/migrate'
import { getPayload } from 'payload'

const payload = await getPayload({ config: configPath })

// Migrate specific collection
const posts = await payload.find({
  collection: 'posts',
  limit: 1000,
})

for (const post of posts.docs) {
  if (post.content && typeof post.content === 'object') {
    const lexicalContent = convertSlateToLexical(post.content)
    
    await payload.update({
      collection: 'posts',
      id: post.id,
      data: {
        content: lexicalContent,
      },
    })
  }
}
```

### From Legacy Versions

Breaking changes and migration steps between major versions:

#### Version 3.x to 4.x Migration

```typescript
// Update import paths
// OLD
import { lexicalEditor } from '@payloadcms/richtext-lexical'

// NEW (same, no changes)
import { lexicalEditor } from '@payloadcms/richtext-lexical'

// Feature configuration changes
// OLD
features: [BoldFeature, ItalicFeature]

// NEW (function call required)
features: [BoldFeature(), ItalicFeature()]
```

## Example Projects

- [Blog Starter](https://github.com/payloadcms/payload/tree/main/examples/blog) - Complete blog with Lexical editor
- [E-commerce](https://github.com/payloadcms/payload/tree/main/examples/ecommerce) - Product descriptions with custom blocks
- [Corporate Website](https://github.com/payloadcms/payload/tree/main/examples/corporate) - Advanced page building with BlocksFeature
- [Documentation Site](https://github.com/payloadcms/payload/tree/main/examples/docs) - Technical documentation with code blocks and syntax highlighting

## Contributing

Found a bug or have a suggestion? [Open an issue](https://github.com/payloadcms/payload/issues/new?assignees=&labels=richtext%3A%20lexical&template=bug_report.md&title=richtext-lexical%3A) or submit a Pull Request.

### Development Setup

```bash
# Clone the repository
git clone https://github.com/payloadcms/payload.git
cd payload/packages/richtext-lexical

# Install dependencies
pnpm install

# Start development
pnpm dev

# Run tests
pnpm test

# Build package
pnpm build
```

## License

MIT License - see the [LICENSE.md](https://github.com/payloadcms/payload/blob/main/packages/richtext-lexical/LICENSE.md) file for details.